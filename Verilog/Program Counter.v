/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module Clock_Module (
  input RST,
  input Mode, // Single-Step Mode/Full Speed Mode
  input CLK,
  input CLKA, // Automated Clock
  output SYNCLK, // Synchronized Clock
  output SYNRST // Synchronized Reset (Active LOW)

);
  wire s0;
  wire SYNCLK_temp;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  Mux_2x1 Mux_2x1_i0 (
    .sel( s0 ),
    .in_0( CLK ),
    .in_1( CLKA ),
    .out( SYNCLK_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( 1'b1 ),
    .C( SYNCLK_temp ),
    .Clr( RST ),
    .Q( s1 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s1 ),
    .C( SYNCLK_temp ),
    .Clr( RST ),
    .Q( s2 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( s2 ),
    .C( SYNCLK_temp ),
    .Clr( RST ),
    .Q( s3 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( s3 ),
    .C( SYNCLK_temp ),
    .Clr( RST ),
    .Q( SYNRST )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i5 (
    .D( s4 ),
    .C( Mode ),
    .Q( s0 )
  );
  assign s4 = ~ s0;
  assign SYNCLK = SYNCLK_temp;
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Program_Counter (
  input RST,
  input Mode, // Single-Step Mode/Full Speed Mode
  input CLK,
  input CLKA,
  input [15:0] AAJ, // Absolute Address Jump Input
  input [1:0] SS, // Step Size
                  // 00 - 1-byte step
                  // 01 - 2-byte step
                  // 10 - 3-byte step
                  // 11 - 4-byte step
  input [15:0] JO, // Jump Offset
  input [1:0] JS, // Jump Select
                  // 00 - NONE (Stall)
                  // 01 - Single-Step
                  // 10 - Relative Jump Address
                  // 11 - FIxed Jump Address
  input CE, // Clock Enable
  output [15:0] Q
);
  wire s0;
  wire s1;
  wire [15:0] s2;
  wire s3;
  wire [15:0] Q_temp;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  Clock_Module Clock_Module_i0 (
    .RST( RST ),
    .Mode( Mode ),
    .CLK( CLK ),
    .CLKA( CLKA ),
    .SYNCLK( s0 ),
    .SYNRST( s1 )
  );
  assign s5[1:0] = SS;
  assign s5[15:2] = 14'b0;
  assign s3 = ~ (CE & s1);
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( s2 ),
    .C( s0 ),
    .en( s3 ),
    .Q( Q_temp )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i2 (
    .a( Q_temp ),
    .b( JO ),
    .c_i( 1'b0 ),
    .s( s4 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i3 (
    .a( Q_temp ),
    .b( s5 ),
    .c_i( 1'b1 ),
    .s( s6 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i4 (
    .sel( JS ),
    .in_0( s6 ),
    .in_1( s4 ),
    .in_2( AAJ ),
    .in_3( 16'b0 ),
    .out( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i5 (
    .sel( s1 ),
    .in_0( 16'b0 ),
    .in_1( s7 ),
    .out( s2 )
  );
  assign Q = Q_temp;
endmodule
